<?php
namespace Packfire\PDC\Analyzer;

/**
 * Generated by PHPUnit_SkeletonGenerator 1.2.0 on 2013-01-02 at 22:24:24.
 * @group Analyzer
 */
class AnalyzerTest extends \PHPUnit_Framework_TestCase
{
    protected function buildFile($path, $source){
        $file = $this->getMock('\Packfire\PDC\Analyzer\File', array(), array($path));
        $file->expects($this->once())
                ->method('source')
                ->will($this->returnValue($source));
        $file->expects($this->any())
                ->method('path')
                ->will($this->returnValue($path));
        return $file;
    }

    protected function buildReport($file){
        $report = $this->getMock('\Packfire\PDC\Report\Report');
        $report->expects($this->once())
                ->method('processFile')
                ->with($file->path());
        return $report;
    }

    /**
     * @covers Packfire\PDC\Analyzer\Analyzer::analyze
     */
    public function testAnalyze()
    {
        $source = <<<'EOT'
<?php

class Example{

}
EOT;
        $file = $this->buildFile('Test/Example.php', $source);
        $analyzer = new Analyzer($file);
        $analyzer->analyze($this->buildReport($file));
    }

    /**
     * @covers Packfire\PDC\Analyzer\Analyzer::useIndexing
     * @todo utilise provider to load script from file (test data from provider)
     */
    public function testUseIndexing()
    {
        $source = <<<'EOT'
<?php

/**
 *
 * @author https://github.com/goatherd
 *
 */
namespace Vendor\Package;

use Vendor2\Päck as Assert;
  use Doctrine\X\Y AS /*some*/ ORM;
// comment

/*
use something;
 */
use Some\InterfaceInterface, // with comment, mean characters and use something;
    SomeOther\AbstractClass as BaseClass,
YetAnOther\ClassX;

use DateTime;

// that one is not psr-0 but it should work too
' use ClassX;';

/**
 * @ORM\Entity('name')
 * @note tokenizer test
 */
class MyClass extends BaseClass implements InterfaceInterface
{
    /**
     * @Assert\Length(min=3,max=5)
     * @var array
     */
    protected $property;

    /**
     * Some method.
     *
     * @param SomeClass $arg description
     *
     * @return void
     */
    public function someMethod(SomeClass $arg) {}
}
EOT;
        $file = $this->buildFile('Test/Example.php', $source);
        $analyzer = new Analyzer($file);

        $class = new \ReflectionClass(get_class($analyzer));
        $method = $class->getMethod('useIndexing');
        $method->setAccessible(true);

        $report = $method->invokeArgs($analyzer, array());
        $expected = array(
          'Assert' => 'Vendor2\Päck',
          'ORM' => 'Doctrine\X\Y',
          'InterfaceInterface' => 'Some\InterfaceInterface',
          'BaseClass' => 'SomeOther\AbstractClass',
          'ClassX' =>'YetAnOther\ClassX',
          'DateTime' => 'DateTime',
        );
        $this->assertEquals($report, $expected);
    }

    /**
     * @covers Packfire\PDC\Analyzer\Analyzer::findUsages
     * @todo add providers and load scripts from fixtures (might utilise non-mock file wrapper)
     */
    public function testFindUsages()
    {
        $source = <<<'EOT'
<?php

namespace Vendor;

use Vendor2\Package as AnotherVendor;
use Doctrine\SomeClass as ORM;

/**
 * @ORM\Entity(someKey=true)
 */
class Example extends AbstractClass123 implements AnotherVendor\SomeInterface
{
    /**
     * @Assert\NotNull
     * @param ArgumentBaseClass $x
     *
     * @return \Vendor\Example fluent interface
     */
    public function someMethod(\ArgumentClass $x)
    {
        static::$x;
        static::callMe();
        $x = new Exception\InvalidArgumentException();
        return $this;
    }
}
EOT;
        $file = $this->buildFile('Test/Example.php', $source);
        $analyzer = new Analyzer($file);

        $class = new \ReflectionClass(get_class($analyzer));
        $method = $class->getMethod('findUsages');
        $method->setAccessible(true);

        $classes = $method->invokeArgs($analyzer, array());

        // expected result
        $expected = array(
            'AbstractClass123',
            'AnotherVendor\SomeInterface',
            '\ArgumentClass',
            'Exception\InvalidArgumentException',
        );
        // parser does something wrong for `static::*` and returns an empty class name
        $this->assertEquals($classes, $expected);
    }
}
